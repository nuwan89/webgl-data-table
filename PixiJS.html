<!DOCTYPE html>
<!-- saved from url=(0024)http://192.168.1.7:8080/ -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PixiJS</title>

    <script src="./PixiJS_files/pixi.js.download"></script>

</head>

<body>

    <!-- <button onclick="resize()">resize</button> -->

    <!-- <div id="d" style="background-color: blueviolet; width: 300px; height: 200px;"> This is my div</div> -->

    <div class="left">Left content</div>
    <div class="right">Right content</div>
    <div class="tbl"></div>
    <div class="bot-right">Bottom Right content</div>
    <button onclick="changeWidth()">increase canvas width</button>
    <button onclick="shrinkWidth()">shrink canvas width</button>


    <script>
        let table_width = 640;
        let table_height = 360;
        const headers = ["#", "Id", "Name", "Properties"]
        let header_objects = headers.map((h, index) => {
            return { label: h, id: index }
        })
        const data = {}
        //Fill data

        PIXI.BitmapFont.from("TableFont", {
            fontFamily: "Arial",
            fontSize: 16,
            strokeThickness: 2,
            fill: "purple"
        });

        const tx = new PIXI.BitmapText("xxx", { fontName: "TableFont" });


        // let app = new PIXI.Application({ width: table_width, table_height: table_height });
        // let app = new PIXI.Application({ width: table_width, height: table_height });
        // // document.body.appendChild(app.view);
        // document.querySelector('.tbl').appendChild(app.view);
        // app.view.id = 'x'

        draw_headers(header_objects)

        function draw_headers(header_objects) {
            for (const header_obj of header_objects) {
                console.log(get_initial_cell_width(header_obj));
            }
        }

        function get_initial_cell_width(header_object) {
            return header_object.width ? header_object.width : table_width / headers.length
        }


        // Create a Graphics object, set a fill color, draw a rectangle
        // let obj = new PIXI.Graphics();
        // // obj.beginFill(0xff0000);
        // obj.lineStyle(1, 0x00FF00);
        // obj.drawRect(0, 0, 200, 100);

        // // Add it to the stage to render
        // app.stage.addChild(obj);



        const resize = () => {
            console.log((app.view.offsetWidth * 2) + "px");
            app.view.style.width = (app.view.offsetWidth * 2) + "px"
            app.view.style.width = (app.view.offsetHeight * 2) + "px"
        }

        const changeWidth = () => {
            app.view.style.width =  (app.view.offsetWidth + 40) + "px"
        }

        const shrinkWidth = () => {
            app.view.style.width =  (app.view.offsetWidth - 40) + "px"
        }


        class TableContext {
            constructor(width, height, containerElement, pixi) {
                this.width = width
                this.height = height
                this.containerElement = containerElement
                this.pixi = pixi
                // new ResizeObserver(() => {
                //     console.log("Width: " + this.containerElement.offsetWidth + " Hh: " + this.containerElement.offsetHeight);

                // }).observe(this.containerElement)
            }

            table_width() {
                return this.width
            }

            draw(graphics) {
                this.pixi.stage.addChild(graphics)
            }
            
        }

        class Cell {
            constructor(x, y, width, height, context) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.context = context;
            }

            px() {
                console.log(this.x);
            }
        }

        class HeaderCell {
            constructor(index, x, y, width, height, header) {
                this.index = index;
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.header = header;
                this.resizing = false
                this.g = new PIXI.Graphics();
                this.handle = new PIXI.Graphics();
                this.handle.interactive = true;
                // this.handle.hitArea = new PIXI.Rectangle(this.x + this.width - 4, this.y + 2, 10, this.height - 4);
                this.handle.hitArea = new PIXI.Rectangle(this.width - 4, 2, 10, this.height - 4);
                this.text = new PIXI.Text('Id: '+this.width,{fontFamily : 'Arial', fontSize: 16, fill : 0xff1010, align : 'center'});
                this.text.x = this.width/2
                this.container = new PIXI.Container();
                this.g.zIndex = 100
                this.container.addChild(this.g)
                this.container.addChild(this.handle)
                this.container.addChild(this.text)
                this.container.x = this.index * this.width
                this.container.y = this.y
                this.draw()
                this.handle.on('pointerdown', (e) => {
                    this.resizing = true
                    this.start_x = e.data.global.x
                });
                this.handle.on('pointerup', (e) => {
                    this.resizing = false
                });
                this.handle.on('pointerupoutside', (e) => {
                    this.resizing = false
                });
                this.handle.on('pointermove', (e)=>{
                    if (this.resizing) {
                        const distance =  e.data.global.x - this.start_x
                        this.width += distance
                        this.start_x = e.data.global.x
                        this.draw()
                        this.header.notifyListeners(this.index, this.width)
                        this.header.headerCellWidthChanged(this.index, distance)
                    }
                })
                
            }

            draw() {
                // console.log('drawing header cell: '+this.index);
                this.g.clear()
                this.g.lineStyle(1, 0xFF0000);
                // this.g.drawRect(this.x, this.y, this.width, this.height);
                this.g.drawRect(0, 0, this.width, this.height);
                this.handle.clear()
                this.handle.lineStyle(1, 0x00FF00); // Draw resize handle
                // this.handle.drawRect(this.x + this.width - 4, this.y + 2, 10, this.height - 4)
                this.handle.drawRect(this.width - 4, 2, 10, this.height - 4)
                this.handle.hitArea = new PIXI.Rectangle(this.width - 4, 2, 10, this.height - 4);
                // this.text.clear()
                this.text.text = "w: " + (Math.floor(this.container.width))
                this.text.x = this.width/2
                this.container.x = this.x
                return this.container
            }
        }

        class DataCell {

            constructor(index, value, x, y, width, height) { 
                this.index = index
                this.value = value
                this.x = x
                this.y = y
                this.width = width
                this.height = height
                this.container = new PIXI.Graphics()
                this.cellG = new PIXI.Graphics()
                this.text = new PIXI.Text(this.value,{fontFamily : 'Arial', fontSize: 16, fill : 0xff1010, align : 'center'});
                // this.text = new PIXI.BitmapText("this.value", { fontName: "TableFont" });
                // this.text.text = this.value;
                // this.text.text = 'zzz'
                // this.text.x = this.width/2
                // this.container.addChild(this.cellG, this.text)
                this.container.addChild(this.cellG)
                this.container.addChild(this.text)
            }
            
            draw() { 
                this.cellG.clear()
                this.cellG.lineStyle(1, 0x00FF00)
                // this.cellG.drawRect(this.x, this.y, this.width, this.height)
                this.cellG.drawRect(0, 0, this.width, this.height)
                this.container.x = this.x
                this.container.y = this.y
                return this.container
            }

            setX(x) {
                this.container.x = x
                return this.draw()
            }

            setWidth(width) {
                this.cellG.width = width
                return this.draw()
            }
        }

        class Row {
            constructor(columns, index, height, header, context) {
                this.columns = columns
                this.index = index
                this.ctx = context
                this.header = header
                this.height = height
                this.headrOffsetY = this.header.height
                this.cells = []
                header.addColumnChangedListener((columnIndex, newWidth, newX) => {
                    if (newX) {
                        this.ctx.draw(this.cells[columnIndex].setX(newX))
                    }
                    // console.log(this.cells);
                    if (newWidth) {
                        this.ctx.draw(this.cells[columnIndex].setWidth(newWidth))
                    }
                })
                for (let i = 0; i < header.headerCells.length; i++) {
                    const headerCell = header.headerCells[i]
                    const dataCell = new DataCell(i, i*index + i, headerCell.x, this.index * this.height + this.headrOffsetY, headerCell.width, this.height)
                    this.cells.push(dataCell)
                    // this.ctx.draw(dataCell.draw())
                }
            }
        }

        class Header {
            static get Height() { return this.height; }

            constructor(x, y, height, columns, context) {
                this.x = x;
                this.y = y;
                this.height = height;
                this.columns = columns;
                this.ctx = context;
                this.g = new PIXI.Graphics();
                this.headerCells = []
                this.columnListeners = [];
                for(let i = 0; i < this.columns.length; i++) {
                    const cell = new HeaderCell(i, this.x + (i*this.defaultCellWidth), this.y, this.defaultCellWidth, this.height, this)
                    // const cell = new HeaderCell(0, 0, 200, this.height)
                    this.ctx.draw(cell.draw())
                    this.headerCells.push(cell)
                }
            }

            addColumnChangedListener(listener) { 
                this.columnListeners.push(listener)
            }

            get defaultCellWidth() {
                // console.log(this.ctx.width/this.columns.length);
                return this.ctx.width/this.columns.length
                // return 100
            }

            headerCellWidthChanged(index, distance) {
                // notifyListeners(index, widthChange)
                if ((distance < 0 && this.headerCells[index + 1]) || (distance > 0 && this.headerCells[index + 1])) {
                    let i = index + 1
                    let adjacentResized
                    // this.notifyListeners(i, null, this.headerCells[i].width)
                    while (this.headerCells[i]) {
                        adjacentResized = true
                        this.headerCells[i].x +=  distance
                        this.ctx.draw(this.headerCells[i].draw())
                        this.notifyListeners(i, null, this.headerCells[i].x)
                        i++
                    }
                    if (adjacentResized) {
                        this.headerCells[i-1].width -= distance
                        this.notifyListeners(index, this.headerCells[i-1].width)
                    }
                }
            }

            notifyListeners(columnIndex, newWidth, newX) {
                for (const listener of this.columnListeners) {
                    listener(columnIndex, newWidth, newX)
                }
            }

            draw(width) {
            }
        }

        class ScrollBar {

            static get GRABBER_THICKNESS () { return 2}

            constructor(x, y, barWidth, barHeight, graberWidth, context) {
                this.x = x;
                this.y = y;
                this.barWidth = barWidth;
                this.barHeight = barHeight;
                this.grabberWidth = graberWidth;
                this.grabberHeight = 50;
                this.ctx = context;
                this.scrolling = false
                this.bar = new PIXI.Graphics()
                this.bar.lineStyle(1, 0x00FF00)
                this.bar.drawRect(0, 0, this.barWidth, this.barHeight)
                this.grabber = new PIXI.Graphics()
                this.grabber.x = 0
                this.grabber.y = 0
                // this.grabber.anchor = 0.5;
                this.grabber.interactive = true
                this.grabber.hitArea = new PIXI.Rectangle(0, this.grabber.y, this.grabberWidth, this.grabberHeight);
                this.grabber.lineStyle(ScrollBar.GRABBER_THICKNESS, 0x0000FF)
                this.grabber.drawRect(0, this.grabber.y, this.grabberWidth, this.grabberHeight)
                this.grabber.hitArea = new PIXI.Rectangle(0, this.grabber.y, this.grabberWidth, this.grabberHeight);
                this.container = new PIXI.Container()
                this.container.addChild(this.bar)
                this.container.addChild(this.grabber)
                this.container.x = this.x
                this.container.y = this.y
                this.grabber.on('pointerdown', (e) => {
                    this.grabEvent = e.data
                    this.offY = this.grabber.y - this.grabEvent.getLocalPosition(this.container).y;
                    this.scrolling = true
                });
                this.grabber.on('pointerup', (e) => {
                    this.scrolling = false
                    this.grabEvent = null
                });
                this.grabber.on('pointerupoutside', (e) => {
                    this.scrolling = false
                    this.grabEvent = null
                });
                this.grabber.on('pointermove', (e)=>{
                    if (this.scrolling) {
                        const newPos = this.grabEvent.getLocalPosition(this.container).y + this.offY;
                        // if (newPos >= 0 && newPos <= this.barHeight - this.grabberHeight - ScrollBar.GRABBER_THICKNESS) {
                        if (newPos >= 0 && newPos <= this.barHeight - this.grabberHeight) {
                            this.grabber.y = newPos;
                            // console.log(newPos);
                            // console.log(this.scrollY);
                            this.scrollListener(this.grabber.y)
                        }
                    }
                })
                this.ctx.draw(this.container)
            }

            setScrollListener(func) {
                this.scrollListener = func
            }

            get scrollY () { return this.grabber.y; }
        }

        class Table {

            static get SCROLL_WIDTH() { return 10 }
            static get HEADER_HEIGHT() { return 20 }

            constructor(headers, rows, tableWidth, tableHeight) {
                this.rows = rows;
                this.tableWidth = tableWidth;
                this.tableHeight = tableHeight;
                this.app = new PIXI.Application({ width: this.tableWidth, height: this.tableHeight });
                this.ctx = new TableContext(this.tableWidth, this.tableHeight, this.app.view, this.app)
                this.header = new Header(0, 0, Table.HEADER_HEIGHT, headers, this.ctx)
                this.scrollbar = new ScrollBar(this.tableWidth - Table.SCROLL_WIDTH, Table.HEADER_HEIGHT, Table.SCROLL_WIDTH, this.tableHeight-Table.HEADER_HEIGHT, Table.SCROLL_WIDTH, this.ctx)
                this.scrollbar.setScrollListener((y)=>{
                    // this.renderRows(this.visibleRowStart)
                    // const p = Math.floor((y/(this.scrollbar.barHeight - this.scrollbar.grabberHeight)) * this.rows.length)
                    const p = Math.floor((Math.round(y)/(this.scrollbar.barHeight - this.scrollbar.grabberHeight)) * this.rows.length)
                    // const p = Math.floor((y/(this.scrollbar.barHeight - this.scrollbar.grabberHeight)) * 100)
                    // const p = (y/(this.scrollbar.barHeight - this.scrollbar.grabberHeight) * 100)
                    // console.log(this.rows.length+'===');
                    // console.log(p);
                    // console.log(y);
                    this.renderRows(p)
                })
                this.renderedRows = []
                this.dataCellContainer = new PIXI.Container()
                this.renderRows(this.visibleRowStart)
                this.ctx.draw(this.dataCellContainer)
                // console.log(this.scrollbar.scrollY);
                // **************** Rendering rows ***********************************
                // this.app.ticker.add(() => this.draw());
                // this.header.draw(100)
                document.querySelector('.tbl').appendChild(this.app.view);
            }
            
            renderRows(fromIndex) {
                // const dataRows = []
                for ( let i = fromIndex; i < (fromIndex + this.viewPortRowCount); i++ ) {
                    // console.log(this.renderedRows);
                    if (!this.renderedRows[i]) {
                        // console.log({fromIndex, toIndex: fromIndex + this.viewPortRowCount});
                        // console.log({fromIndex, to: fromIndex + this.viewPortRowCount});
                        const row = new Row(headers, i, Table.HEADER_HEIGHT, this.header, this.ctx)
                        // **************************** Add data cells to a group and render them ****************************
                        for (let j = 0; j < row.cells.length; j++) {
                            this.dataCellContainer.addChild(row.cells[j].draw());
                        }
                        this.renderedRows[i] = row
                    }
                    // this.addColumnChangedListener()
                    // this.rowG = new PIXI.Graphics()
                }
                this.dataCellContainer.y = fromIndex * -Table.HEADER_HEIGHT
            }

            get visibleRowStart () { return Math.floor(this.scrollbar.scrollY/Table.HEADER_HEIGHT) }

            get viewPortRowCount() {
                // console.log((this.tableHeight - Table.HEADER_HEIGHT));
                return Math.round((this.tableHeight - Table.HEADER_HEIGHT)/Table.HEADER_HEIGHT) // cache this for performance
            }
        }

        let rows = []
        for (let i = 0; i < 1000; i++) {
            rows.push({ id: i, name: 'Product - ' + i, description: 'Desc000000', price: 1000.00 })
        }
        new Table(headers, rows, table_width, table_height)


//    new ResizeObserver(() => {
//                     console.log("Width: " + app.view.offsetWidth + " H: " + app.view.offsetHeight);
                    
//                 }).observe(app.view)

        // }, app.view)
    </script>
    
    <!-- <canvas width="640" height="600" id="x" style="touch-action: none; cursor: inherit;"></canvas> -->


   

    <style>
        body {
            background-color: burlywood;
            display: grid;
            gap: 1rem;
            grid-template-columns: repeat(2, 1fr);

        }
        body div {
            background-color: darkgrey;
        }
    </style>



</body>
</html>
<!DOCTYPE html>
<!-- saved from url=(0024)http://192.168.1.7:8080/ -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PixiJS</title>

    <script src="./PixiJS_files/pixi.js.download"></script>

</head>

<body>

    <!-- <button onclick="resize()">resize</button> -->

    <!-- <div id="d" style="background-color: blueviolet; width: 300px; height: 200px;"> This is my div</div> -->

    <div class="left">Left content</div>
    <div class="right">Right content</div>
    <div class="tbl"></div>
    <div class="bot-right">Bottom Right content</div>
    <button onclick="changeWidth()">increase canvas width</button>
    <button onclick="shrinkWidth()">shrink canvas width</button>


    <script>
        let table_width = 640;
        let table_height = 360;
        const headers = ["#", "Id", "Name", "Properties"]
        let header_objects = headers.map((h, index) => {
            return { label: h, id: index }
        })
        const data = {}
        //Fill data


        // let app = new PIXI.Application({ width: table_width, table_height: table_height });
        // let app = new PIXI.Application({ width: table_width, height: table_height });
        // // document.body.appendChild(app.view);
        // document.querySelector('.tbl').appendChild(app.view);
        // app.view.id = 'x'

        draw_headers(header_objects)

        function draw_headers(header_objects) {
            for (const header_obj of header_objects) {
                console.log(get_initial_cell_width(header_obj));
            }
        }

        function get_initial_cell_width(header_object) {
            return header_object.width ? header_object.width : table_width / headers.length
        }


        // Create a Graphics object, set a fill color, draw a rectangle
        // let obj = new PIXI.Graphics();
        // // obj.beginFill(0xff0000);
        // obj.lineStyle(1, 0x00FF00);
        // obj.drawRect(0, 0, 200, 100);

        // // Add it to the stage to render
        // app.stage.addChild(obj);



        const resize = () => {
            // console.log(app.view);
            // let d = document.getElementById('d')
            // console.log(d);
            console.log((app.view.offsetWidth * 2) + "px");
            app.view.style.width = (app.view.offsetWidth * 2) + "px"
            app.view.style.width = (app.view.offsetHeight * 2) + "px"
        }

        const changeWidth = () => {
            app.view.style.width =  (app.view.offsetWidth + 40) + "px"
        }

        const shrinkWidth = () => {
            app.view.style.width =  (app.view.offsetWidth - 40) + "px"
        }


        class TableContext {
            constructor(width, height, containerElement, pixi) {
                this.width = width
                this.height = height
                this.containerElement = containerElement
                this.pixi = pixi
                // new ResizeObserver(() => {
                //     console.log("Width: " + this.containerElement.offsetWidth + " Hh: " + this.containerElement.offsetHeight);

                // }).observe(this.containerElement)

            }

            table_width() {
                return this.width
            }

            draw(graphics) {
                
                // let app = new PIXI.Application({ width: table_width, height: table_height });
                // document.querySelector('.tbl').appendChild(app.view);
                // let obj = new PIXI.Graphics();
                // obj.beginFill(0xff0000);
                // obj.lineStyle(1, 0x00FF00);
                // obj.drawRect(0, 0, 200, 100);
                // this.pixi.stage.addChild(graphics)
                // this.pixi.stage.addChild(obj)
                // console.log('drawing');
                this.pixi.stage.addChild(graphics)
            }

            

            
        }

        class Cell {
            constructor(x, y, width, height, context) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.context = context;
            }

            px() {
                console.log(this.x);
            }
        }

        class HeaderCell {
            constructor(index, x, y, width, height, header) {
                this.index = index;
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.header = header;
                this.resizing = false
                this.g = new PIXI.Graphics();
                this.handle = new PIXI.Graphics();
                this.handle.interactive = true;
                // this.handle.hitArea = new PIXI.Rectangle(this.x + this.width - 4, this.y + 2, 10, this.height - 4);
                this.handle.hitArea = new PIXI.Rectangle(this.width - 4, 2, 10, this.height - 4);
                this.text = new PIXI.Text('Id: '+this.width,{fontFamily : 'Arial', fontSize: 16, fill : 0xff1010, align : 'center'});
                this.text.x = this.width/2
                this.container = new PIXI.Container();
                this.container.addChild(this.g)
                this.container.addChild(this.handle)
                this.container.addChild(this.text)
                this.container.x = this.index * this.width
                this.container.y = this.y
                this.draw()
                this.handle.on('pointerdown', (e) => {
                    this.resizing = true
                    this.start_x = e.data.global.x
                });
                this.handle.on('pointerup', (e) => {
                    this.resizing = false
                });
                this.handle.on('pointerupoutside', (e) => {
                    this.resizing = false
                });
                this.handle.on('pointermove', (e)=>{
                    if (this.resizing) {
                        const distance =  e.data.global.x - this.start_x
                        this.width += distance
                        this.start_x = e.data.global.x
                        this.draw()
                        this.header.headerCellWidthChanged(this.index, distance)
                    }
                })
                
            }

            draw() {
                // console.log('drawing header cell: '+this.index);
                this.g.clear()
                this.g.lineStyle(1, 0xFF0000);
                // this.g.drawRect(this.x, this.y, this.width, this.height);
                this.g.drawRect(0, 0, this.width, this.height);
                this.handle.clear()
                this.handle.lineStyle(1, 0x00FF00); // Draw resize handle
                // this.handle.drawRect(this.x + this.width - 4, this.y + 2, 10, this.height - 4)
                this.handle.drawRect(this.width - 4, 2, 10, this.height - 4)
                this.handle.hitArea = new PIXI.Rectangle(this.width - 4, 2, 10, this.height - 4);
                // this.text.clear()
                this.text.text = "w: " + (Math.floor(this.container.width))
                this.text.x = this.width/2
                this.container.x = this.x
                return this.container
            }
        }

        class Header {
            static get Height() { return this.height; }

            constructor(x, y, height, columns, context) {
                this.x = x;
                this.y = y;
                this.height = height;
                this.columns = columns;
                this.ctx = context;
                this.g = new PIXI.Graphics();
                this.headerCells = []
                for(let i = 0; i < this.columns.length; i++) {
                    const cell = new HeaderCell(i, this.x + (i*this.defaultCellWidth), this.y, this.defaultCellWidth, this.height, this)
                    // const cell = new HeaderCell(0, 0, 200, this.height)
                    this.ctx.draw(cell.draw())
                    this.headerCells.push(cell)
                }
            }

            get defaultCellWidth() {
                // console.log(this.ctx.width/this.columns.length);
                return this.ctx.width/this.columns.length
                // return 100
            }

            headerCellWidthChanged(index, distance) {
                if ((distance < 0 && this.headerCells[index + 1]) || (distance > 0 && this.headerCells[index + 1])) {
                    let i = index + 1
                    let adjacentResized
                    while (this.headerCells[i]) {
                        adjacentResized = true
                        this.headerCells[i].x +=  distance
                        this.ctx.draw(this.headerCells[i].draw())
                        i++
                    }
                    if (adjacentResized) {
                        this.headerCells[i-1].width -= distance
                    }
                }
            }

            draw(width) {
            }
        }

        class ScrollBar {

            static get GRABBER_THICKNESS () { return 2}

            constructor(x, y, barWidth, barHeight, graberWidth, context) {
                this.x = x;
                this.y = y;
                this.barWidth = barWidth;
                this.barHeight = barHeight;
                this.grabberWidth = graberWidth;
                this.grabberHeight = 50;
                this.ctx = context;
                this.scrolling = false
                this.bar = new PIXI.Graphics()
                this.bar.lineStyle(1, 0x00FF00)
                this.bar.drawRect(0, 0, this.barWidth, this.barHeight)
                this.grabber = new PIXI.Graphics()
                this.grabber.x = 0
                this.grabber.y = 0
                // this.grabber.anchor = 0.5;
                this.grabber.interactive = true
                this.grabber.hitArea = new PIXI.Rectangle(0, this.grabber.y, this.grabberWidth, this.grabberHeight);
                this.grabber.lineStyle(ScrollBar.GRABBER_THICKNESS, 0x0000FF)
                this.grabber.drawRect(0, this.grabber.y, this.grabberWidth, this.grabberHeight)
                this.grabber.hitArea = new PIXI.Rectangle(0, this.grabber.y, this.grabberWidth, this.grabberHeight);
                this.container = new PIXI.Container()
                this.container.addChild(this.bar)
                this.container.addChild(this.grabber)
                this.container.x = this.x
                this.container.y = this.y
                this.grabber.on('pointerdown', (e) => {
                    this.grabEvent = e.data
                    this.offY = this.grabber.y - this.grabEvent.getLocalPosition(this.container).y;
                    this.scrolling = true
                });
                this.grabber.on('pointerup', (e) => {
                    this.scrolling = false
                    this.grabEvent = null
                });
                this.grabber.on('pointerupoutside', (e) => {
                    this.scrolling = false
                    this.grabEvent = null
                });
                this.grabber.on('pointermove', (e)=>{
                    if (this.scrolling) {
                        const newPos = this.grabEvent.getLocalPosition(this.container).y + this.offY;
                        if (newPos >= 0 && newPos <= this.barHeight - this.grabberHeight - ScrollBar.GRABBER_THICKNESS) {
                            this.grabber.y = newPos;
                        }
                    }
                })
                this.ctx.draw(this.container)
            }
        }

        class Table {

            static get SCROLL_WIDTH() { return 10 }
            static get HEADER_HEIGHT() { return 20 }

            constructor(headers, rows) {
                this.app = new PIXI.Application({ width: table_width, height: table_height });
                this.ctx = new TableContext(table_width, table_height, this.app.view, this.app)
                this.header = new Header(0, 0, 20, headers, this.ctx)
                this.scrollbar = new ScrollBar(table_width - Table.SCROLL_WIDTH, Table.HEADER_HEIGHT, Table.SCROLL_WIDTH, table_height-Table.HEADER_HEIGHT, Table.SCROLL_WIDTH, this.ctx)
                // this.app.ticker.add(() => this.draw());
                // this.header.draw(100)
                document.querySelector('.tbl').appendChild(this.app.view);
            }
        }

        let rows = []
        for (let i = 0; i < 1000; i++) {
            rows.push({ id: i, name: 'Product - ' + i, description: 'Desc000000', price: 1000.00 })
        }
        new Table(headers, rows)


//    new ResizeObserver(() => {
//                     console.log("Width: " + app.view.offsetWidth + " H: " + app.view.offsetHeight);
                    
//                 }).observe(app.view)

        // }, app.view)
    </script>
    
    <!-- <canvas width="640" height="600" id="x" style="touch-action: none; cursor: inherit;"></canvas> -->


   

    <style>
        body {
            background-color: burlywood;
            display: grid;
            gap: 1rem;
            grid-template-columns: repeat(2, 1fr);

        }
        body div {
            background-color: darkgrey;
        }
    </style>



</body>
</html>